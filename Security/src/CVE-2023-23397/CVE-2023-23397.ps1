# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
#Requires -Version 3.0

<#
.SYNOPSIS
    This script audits mails, calendar and task items and check if PidLidReminderFileParameter property is populated or not.
    If required admins can use this script to cleanup the property for items they find malicious or even delete these items permanently.
.DESCRIPTION
    There are two modes in which we can run the script Audit and Cleanup.

    Audit Mode: Script provides a csv to the admins with details of items that have PidLidReminderFileParameter property populated.
    Cleanup Mode: Script performs Cleanup action on items by either clearing the property or deleting the mail itself.

    Prerequisites to run the script for Exchange Server on-premises: You need to have ApplicationImpersonation role.
    You can create a new role group with the required permissions by running the following PowerShell command in an elevated Exchange Management Shell (EMS):
    `New-RoleGroup -Name "CVE-2023-23397-Script" -Roles "ApplicationImpersonation" -Description "Permission to run the CVE-2023-23397 script"`

    Prerequisites to run the script for Exchange Online: You need to be a member of Organization Management.
    The script will create an application with full access permission on all the mailboxes.

    The script uses EWS managed api to make ews calls in order to fetch items from user mailboxes.
    So the machine on which the script is run should be able to make EWS calls to Exchange Server.
.PARAMETER CreateAzureApplication
    Use this switch to create a Azure AD application that can be used for running the script in online mode
.PARAMETER DeleteAzureApplication
    Use this switch to delete the Azure AD application
.PARAMETER UserMailboxes
    Use this parameter to provide list of user primary SMTP address.
.PARAMETER StartTimeFilter
    Use this parameter to provide start time filter
.PARAMETER EndTimeFilter
    Use this parameter to provide end time filter
.PARAMETER CleanupAction
    Use this parameter to provide type of cleanup action you want to provide (ClearProperty/ClearItem)
.PARAMETER CleanupInfoFilePath
    Use this parameter to provide path to the csv file containing the details of items to be cleaned up
.PARAMETER EWSExchange2013
    Use this switch if you are running on Exchange 2013 server mailboxes
.PARAMETER MaxCSVLength
    This optional parameter allows you to provide maximum csv length
.PARAMETER AzureEnvironmentName
    This optional parameter allows you to provide Azure environment
.PARAMETER AzureApplicationName
    This optional parameter allows you to provide Azure application name
.PARAMETER EWSOnlineURL
    This optional parameter allows you to provide EWS online url
.PARAMETER EWSOnlineScope
    This optional parameter allows you to provide EWS online scope
.PARAMETER AzureADEndpoint
    This optional parameter allows you to provide Azure AD endpoint
.PARAMETER EWSServerURL
    This optional parameter allows you to provide EWS server URL
.PARAMETER DLLPath
    This optional parameter allows you to provide the path to Microsoft.Exchange.WebServices.dll
.PARAMETER ScriptUpdateOnly
    This optional parameter allows you to only update the script without performing any other actions.
.PARAMETER SkipVersionCheck
    This optional parameter allows you to skip the automatic version check and script update.
.PARAMETER IgnoreCertificateMismatch
    This optional parameter lets you ignore TLS certificate mismatch errors.
.PARAMETER Credential
    This optional parameter lets you pass administrator credential object while running on Exchange Server on-premises.
.PARAMETER TimeoutSeconds
    This optional parameter lets you specify the timeout value for the ExchangeService object. Defaults to 5 minutes.
.EXAMPLE
    PS C:\> .\CVE-2023-23397.ps1 -CreateAzureApplication
    This will run the tool to create a new Azure application with required permissions
.EXAMPLE
    PS C:\> (Get-Mailbox).PrimarySMTPAddress | .\CVE-2023-23397.ps1 -Environment <Online/Onprem>
    This will run the tool in audit mode on all the users present
.EXAMPLE
    PS C:\> .\CVE-2023-23397.ps1 -Environment <Online/Onprem> -CleanupAction ClearItem -CleanupInfoFilePath <path to csv file>
    This will run the tool in clean up mode and clear all the items mentioned in the csv file
#>
[CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]

param(
    [ValidateSet("Online", "Onprem")]
    [Parameter(Mandatory=$true, ParameterSetName="Audit")]
    [Parameter(Mandatory=$true, ParameterSetName="Cleanup")]
    [String]$Environment,

    [Parameter(Mandatory=$true, ParameterSetName="CreateAzureApplication")]
    [Switch]$CreateAzureApplication,

    [Parameter(Mandatory=$true, ParameterSetName="DeleteAzureApplication")]
    [Switch]$DeleteAzureApplication,

    [Parameter(Mandatory=$true, ParameterSetName="Audit", ValueFromPipelineByPropertyName = $true)]
    [Alias("PrimarySmtpAddress")]
    [String[]]$UserMailboxes,

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [DateTime]$StartTimeFilter,

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [DateTime]$EndTimeFilter,

    [ValidateSet("ClearProperty", "ClearItem")]
    [Parameter(Mandatory=$true, ParameterSetName="Cleanup")]
    [string]$CleanupAction,

    [ValidateScript({ Test-Path -Path $_ -PathType leaf })]
    [Parameter(Mandatory=$true, ParameterSetName="Cleanup")]
    [ValidatePattern("(.*?)\.(csv)$")]
    [string]$CleanupInfoFilePath,

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [switch]$EWSExchange2013,

    [ValidateRange(1, [Int]::MaxValue)]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Int]$MaxCSVLength = 200000,

    [Parameter(Mandatory=$false, ParameterSetName="CreateAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="DeleteAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [String]$AzureEnvironmentName = "AzureCloud",

    [Parameter(Mandatory=$false, ParameterSetName="CreateAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="DeleteAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [String]$AzureApplicationName = "CVE-2023-23397Application",

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [Uri]$EWSOnlineURL = "https://outlook.office365.com/EWS/Exchange.asmx",

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [String]$EWSOnlineScope = "https://outlook.office365.com/.default",

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [Uri]$AzureADEndpoint = "https://login.microsoftonline.com/",

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [Uri]$EWSServerURL,

    [ValidateScript({ Test-Path $_ })]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [String]$DLLPath,

    [Parameter(Mandatory=$true, ParameterSetName="ScriptUpdateOnly")]
    [switch]$ScriptUpdateOnly,

    [Parameter(Mandatory=$false, ParameterSetName="CreateAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="DeleteAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [switch]$SkipVersionCheck,

    [Parameter(Mandatory=$false, ParameterSetName="CreateAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="DeleteAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [switch]$IgnoreCertificateMismatch,

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [ValidateRange(1, 2147483)]
    [int]$TimeoutSeconds = 300
)

dynamicparam {
    if ($Environment -eq "Onprem") {
        $auditParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Audit"
            Mandatory        = $true
        }

        $cleanupParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Cleanup"
            Mandatory        = $true
        }
    } else {
        $auditParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Audit"
            Mandatory        = $false
        }

        $cleanupParameterAttribute = [System.Management.Automation.ParameterAttribute]@{
            ParameterSetName = "Cleanup"
            Mandatory        = $false
        }
    }

    $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
    $attributeCollection.Add($auditParameterAttribute)
    $attributeCollection.Add($cleanupParameterAttribute)

    $credentialType = [System.Management.Automation.PSCredential]
    $dynParameter = New-Object System.Management.Automation.RuntimeDefinedParameter 'Credential', $credentialType, $attributeCollection

    $paramDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
    $paramDictionary.Add('Credential', $dynParameter)
    return $paramDictionary
}

begin {
    $BuildVersion = ""
    $credential = $PSBoundParameters['Credential']

    . $PSScriptRoot\WriteFunctions.ps1
    . $PSScriptRoot\..\..\..\Shared\CertificateFunctions\Enable-TrustAnyCertificateCallback.ps1
    . $PSScriptRoot\..\..\..\Shared\OutputOverrides\Write-Host.ps1
    . $PSScriptRoot\..\..\..\Shared\OutputOverrides\Write-Verbose.ps1
    . $PSScriptRoot\..\..\..\Shared\OutputOverrides\Write-Warning.ps1
    . $PSScriptRoot\..\..\..\Shared\ScriptUpdateFunctions\Test-ScriptVersion.ps1
    . $PSScriptRoot\..\..\..\Shared\Get-NuGetPackage.ps1
    . $PSScriptRoot\..\..\..\Shared\Invoke-ExtractArchive.ps1
    . $PSScriptRoot\..\..\..\Shared\LoggerFunctions.ps1
    . $PSScriptRoot\..\..\..\Shared\Show-Disclaimer.ps1

    $loggerParams = @{
        LogName                  = "CVE-2023-23397-$((Get-Date).ToString("yyyyMMddhhmmss"))-Debug"
        AppendDateTimeToFileName = $false
        ErrorAction              = "SilentlyContinue"
    }

    $Script:Logger = Get-NewLoggerInstance @loggerParams

    SetWriteHostAction ${Function:Write-HostLog}
    SetWriteVerboseAction ${Function:Write-VerboseLog}
    SetWriteWarningAction ${Function:Write-HostLog}

    $mode = $PsCmdlet.ParameterSetName

    ## function to create ews managed api service object
    function EWSAuth {
        param(
            [string]$Environment,
            $token,
            $EWSOnlineURL,
            $EWSServerURL
        )
        ## Create the Exchange Service object with credentials
        if ($EWSExchange2013) {
            $Service = New-Object Microsoft.Exchange.WebServices.Data.ExchangeService([Microsoft.Exchange.WebServices.Data.ExchangeVersion]::Exchange2013)
        } else {
            $Service = New-Object Microsoft.Exchange.WebServices.Data.ExchangeService([Microsoft.Exchange.WebServices.Data.ExchangeVersion]::Exchange2016)
        }

        $Service.Timeout = $TimeoutSeconds * 1000

        if ($Environment -eq "Onprem") {
            $Service.Credentials = New-Object Microsoft.Exchange.WebServices.Data.WebCredentials($credential.UserName, [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)))
        } else {
            $Service.Credentials = New-Object Microsoft.Exchange.WebServices.Data.OAuthCredentials($token.access_token)
        }

        if ($Environment -eq "Onprem") {
            if (-not([System.String]::IsNullOrEmpty($EWSServerURL))) {
                $Service.Url = New-Object Uri($EWSServerURL)
                CheckOnpremCredentials -ewsService $Service
            } else {
                try {
                    $Service.AutodiscoverUrl($Credential.UserName)
                } catch [Microsoft.Exchange.WebServices.Data.AutodiscoverLocalException] {
                    Write-Host "Username: $($Credential.UserName) was passed in UPN format but must use a domain which is an accepted domain by Exchange Server." -ForegroundColor Red
                    Write-Host "You must use the -EWSServerURL parameter if the UPN does not match an email domain used by Exchange." -ForegroundColor Red
                    Write-Host "More information: https://aka.ms/CVE-2023-23397ScriptDoc" -ForegroundColor Red
                    Write-Host "Inner Exception`n`n$_" -ForegroundColor Red
                    exit
                } catch [System.FormatException] {
                    Write-Host "Username: $($Credential.UserName) was passed in Domain\SamAccountName format" -ForegroundColor Red
                    Write-Host "You must use the -EWSServerURL parameter if the username is provided in domain\user format." -ForegroundColor Red
                    Write-Host "More information: https://aka.ms/CVE-2023-23397ScriptDoc" -ForegroundColor Red
                    Write-Host "Inner Exception`n`n$_" -ForegroundColor Red
                    exit
                } catch {
                    Write-Host "Unable to make Autodiscover call to fetch EWS endpoint details. Please make sure you have enter valid credentials. Inner Exception`n`n$_" -ForegroundColor Red
                    exit
                }
            }
        } else {
            $Service.Url = $EWSOnlineURL
        }

        return $Service
    }

    ## function to validate onprem credential
    function CheckOnpremCredentials {
        param (
            $ewsService
        )

        try {
            $null = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($ewsService, [Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::MsgFolderRoot)
        } catch [Microsoft.Exchange.WebServices.Data.ServiceRequestException] {
            Write-Host "Unable to connect to EWS endpoint. Please make sure you have enter valid credentials. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        } catch [Microsoft.Exchange.WebServices.Data.ServiceResponseException] {
            if ($_.Exception.ErrorCode -eq "ErrorNonExistentMailbox") {
                # This is fine. This means this account is not mail-enabled, but credentials worked.
                return
            } elseif ($_.Exception.ErrorCode -eq "ErrorMissingEmailAddress") {
                # On Exchange 2013, even if we handle this error, it doesn't work.
                Write-Host "Could not open mailbox due to ErrorMissingEmailAddress. If running on Exchange 2013, the impersonation user must have a mailbox on prem. Inner Exception`n`n$_" -ForegroundColor Red
                exit
            } else {
                Write-Host "Could not open mailbox. Inner Exception`n`n$_" -ForegroundColor Red
                exit
            }
        } catch {
            Write-Host "Could not open mailbox. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }
    }

    ## function to add a row to the csv
    function CreateCustomCSV {
        param (
            $mailbox,
            $data,
            [string]$CsvPath
        )

        $ItemType = $data.ItemClass

        if ($data.ItemClass.StartsWith("IPM.Note")) {
            $ItemType = "E-Mail"
        } elseif ($data.ItemClass.StartsWith("IPM.Appointment")) {
            $ItemType = "Calendar"
        } elseif ($data.ItemClass.StartsWith("IPM.Task")) {
            $ItemType = "Task"
        }

        $row = [PSCustomObject]@{
            "Mailbox"                     = $mailbox
            "Id"                          = $data.Id
            "ItemType"                    = $ItemType
            "Sender"                      = ($data.From | Select-Object -ExpandProperty Address) -join ","
            "Recipient"                   = ($data.ToRecipients | Select-Object -ExpandProperty Address) -join ","
            "Subject"                     = $data.Subject
            "DateReceived"                = $data.DateTimeReceived
            "PidLidReminderFileParameter" = $data.ExtendedProperties[0].Value
            "Cleanup"                     = "N"
        }

        $row | Export-Csv -Path $CsvPath -Delimiter ',' -NoTypeInformation -Append -Encoding utf8 -Force
    }

    # Define a function to get all the SubFolders of a given folder
    function GetSubFolders {
        param (
            $folder,
            $foldersList
        )
        # Get the SubFolders of the folder
        $folderView = New-Object Microsoft.Exchange.WebServices.Data.FolderView(100)
        do {
            $folder.FindFolders($folderView) | ForEach-Object {
                # Add the folder path to the list
                $null = $foldersList.Add($_)
                # Recursively get the SubFolders of this folder
                GetSubFolders -folder $_ -foldersList $foldersList
            }
            $folderView.Offset += $result.Folders.Count
        } while ($result.MoreAvailable -eq $true)
    }

    ## function to find item on basis of store ID
    function FindItem {
        param (
            [Microsoft.Exchange.WebServices.Data.ExchangeService]$exchangeService,
            [string]$Id
        )
        $ps = New-Object Microsoft.Exchange.WebServices.Data.PropertySet(New-Object Microsoft.Exchange.WebServices.Data.ExtendedPropertyDefinition([Microsoft.Exchange.WebServices.Data.DefaultExtendedPropertySet]::Common, 0x0000851F, [Microsoft.Exchange.WebServices.Data.MapiPropertyType]::String))
        return [Microsoft.Exchange.WebServices.Data.Item]::Bind($exchangeService, $Id, $ps);
    }

    ## function to create OAuth token
    function CreateOAUTHToken {
        param (
            [string]$TenantID,
            [string]$ClientID,
            [string]$AppSecret,
            [string]$AzureADEndpoint,
            [string]$Scope
        )

        try {
            $body=@{
                scope         = $Scope
                client_id     = $ClientID
                client_secret = $AppSecret
                grant_type    = "client_credentials"
            }

            $PostSplat = @{
                ContentType = 'application/x-www-form-urlencoded'
                Method      = 'POST'

                # Create string by joining bodyList with '&'
                Body        = $body
                Uri         = "$AzureADEndpoint$TenantID/oauth2/v2.0/token"
            }

            $Token = Invoke-RestMethod @PostSplat
        } catch {
            Write-Host "`nFailure creating EWS auth token, exiting Program. Please review the error message below and re-run the program:`n`n$_" -ForegroundColor Red
            exit
        }

        $script:tokenLastRefreshTime = (Get-Date)

        return $Token
    }

    function ConnectAzureAD {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory=$true)]
            [string]$AzureEnvironmentName
        )

        try {
            Import-Module "AzureAD" -ErrorAction Stop
            Write-Host "`nPrompting user for authentication, please minimize this window if you do not see an authorization prompt as it may be in the background"
            Connect-AzureAD -AzureEnvironmentName $AzureEnvironmentName -ErrorAction Stop
        } catch [System.IO.FileNotFoundException] {
            Write-Host "The AzureAD module was not found on this computer. Please install it by running: Install-Module -Name `"AzureAD`"" -ForegroundColor Red
            Write-Host "AzureAD module requires PowerShell version 5.0 or higher. You're running PowerShell $($PSVersionTable.PSVersion)" -ForegroundColor Red
            exit
        } catch {
            Write-Host "Unable to connect to Azure AD. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }
    }

    ## function that create an App secret to for a given application and return it
    function GetApplicationDetails {
        param (
            $AzureApplicationName,
            $AzureEnvironmentName
        )

        ConnectAzureAD -AzureEnvironmentName $AzureEnvironmentName

        try {
            $aadApplication = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"
        } catch {
            Write-Host "No Azure Application found with the name $AzureApplicationName. Please re-run the script with -CreateAzureApplication to create the application. Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }

        if ($null -eq $aadApplication) {
            Write-Host "No Azure Application found with the name $AzureApplicationName. Please re-run the script with -CreateAzureApplication to create the application." -ForegroundColor Red
            exit
        }

        #Assign App Password, make it valid for 7 days
        $appPassword = New-AzureADApplicationPasswordCredential -ObjectId $aadApplication.ObjectId -CustomKeyIdentifier "AppAccessKey" -EndDate (Get-Date).AddDays(7) -ErrorAction Stop

        Write-Host "`nWaiting 60 seconds for app credentials to register.."
        Start-Sleep -Seconds 60
        Write-Host "`nContinuing..."

        return @{
            "TenantID"  = (Get-AzureADTenantDetail).ObjectId
            "ClientID"  = $aadApplication.AppId
            "AppSecret" = $appPassword.Value
        }
    }

    ## function to delete Azure AD application
    function DeleteApplication {
        param (
            $AzureEnvironmentName,
            $AzureApplicationName
        )

        ConnectAzureAD -AzureEnvironmentName $AzureEnvironmentName

        try {
            $app = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"

            if ($null -eq $app) {
                Write-Host "No application with name $AzureApplicationName found" -ForegroundColor Red
                exit
            }

            Remove-AzureADApplication -ObjectId $app.ObjectId

            if (Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'") {
                Write-Host "Unable to delete the Azure AD application. Please try again or delete it manually." -ForegroundColor Red
                exit
            }
        } catch {
            Write-Host "Unable to delete the Azure AD application. Please try again or delete it manually. Inner Exception`n`n$_"
            exit
        }

        Write-Host "Successfully deleted the application $AzureApplicationName" -ForegroundColor Green
    }

    ## function to create Azure AD application
    function CreateApplication {
        param(
            $AzureEnvironmentName,
            $AzureApplicationName
        )

        ConnectAzureAD -AzureEnvironmentName $AzureEnvironmentName

        $aadApplication = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"

        if ($null -ne $aadApplication) {
            Write-Host "Application with name $AzureApplicationName already exists..."
            Write-Host "Client ID: $($aadApplication.AppId)" -ForegroundColor Green
            exit
        }

        ## Creating application with default name
        [string]$appName = $AzureApplicationName

        try {
            $aadApplication = New-AzureADApplication -DisplayName $appName
        } catch {
            Write-Host "`nThere was an error creating the application, please reference the error below and try again Inner Exception`n`n$_" -ForegroundColor Red
            exit
        }

        #Add current user to owner of newly created application
        $currentUser = (Get-AzureADUser -ObjectId (Get-AzureADCurrentSessionInfo).Account.Id)
        Write-Host "`nAdding user $($currentUser.UserPrincipalName) as owner of $appName"
        Add-AzureADApplicationOwner -ObjectId $aadApplication.ObjectId -RefObjectId $currentUser.ObjectId | Out-Null

        #Get Service Principal of MS Graph Resource API
        $ews_SP = Get-AzureADServicePrincipal -All $true | Where-Object { $_.DisplayName -eq "Office 365 Exchange Online" }

        #Initialize RequiredResourceAccess for Microsoft Graph Resource API
        $requiredAccess = New-Object Microsoft.Open.AzureAD.Model.RequiredResourceAccess
        $requiredAccess.ResourceAppId = $ews_SP.AppId
        $requiredAccess.ResourceAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.ResourceAccess]

        #Set Application Permissions
        $ApplicationPermissions = @('full_access_as_app')

        #Add app permissions
        foreach ($permission in $ApplicationPermissions) {
            $reqPermission = $null
            #Get required app permission
            $reqPermission = $ews_SP.AppRoles | Where-Object { $_.Value -eq $permission }
            if ($reqPermission) {
                $resourceAccess = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
                $resourceAccess.Type = "Role"
                $resourceAccess.Id = $reqPermission.Id
                #Add required app permission
                $requiredAccess.ResourceAccess.Add($resourceAccess)
            } else {
                Write-Host "App permission $permission not found in the Graph Resource API" -ForegroundColor Red
            }
        }

        #Add required resource accesses
        $requiredResourcesAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.RequiredResourceAccess]
        $requiredResourcesAccess.Add($requiredAccess)

        #Set permissions in newly created Azure AD App
        $appObjectId=$aadApplication.ObjectId
        Write-Host "`nSetting Azure AD Permissions"
        Set-AzureADApplication -ObjectId $appObjectId -RequiredResourceAccess $requiredResourcesAccess | Out-Null

        #Create Service Principal
        $appId=$aadApplication.AppId
        $servicePrincipal = New-AzureADServicePrincipal -AppId $appId -Tags @("WindowsAzureActiveDirectoryIntegratedApp")

        #Grant Admin Consent for App Permissions
        $requiredResourcesAccess = (Get-AzureADApplication -ObjectId $appObjectId).RequiredResourceAccess

        Write-Host "`nAssigning Necessary Azure AD Service Roles"
        foreach ($resourceAppAccess in $requiredResourcesAccess) {
            $resourceApp = Get-AzureADServicePrincipal -All $true | Where-Object { $_.AppId -eq $resourceAppAccess.ResourceAppId }

            foreach ($permission in $resourceAppAccess.ResourceAccess) {
                if ($permission.Type -eq "Role") {
                    New-AzureADServiceAppRoleAssignment -ObjectId $servicePrincipal.ObjectId -PrincipalId $servicePrincipal.ObjectId -ResourceId $resourceApp.ObjectId -Id $permission.Id | Out-Null
                }
            }
        }

        #Use newly created app to query graphAPI
        [string]$ClientID = $aadApplication.AppId

        Write-Host "Application created with required permissions. Client ID: $ClientID" -ForegroundColor Green
    }

    ## function to check if a given token is expired and renew it
    function CheckTokenExpiry {
        param (
            $applicationInfo,
            [ref]$ewsService,
            [ref]$token,
            [string]$Environment,
            $EWSOnlineURL,
            $EWSOnlineScope,
            $AzureADEndpoint
        )

        if ($Environment -eq "Onprem") {
            return
        }

        # if token is going to expire in next 5 min then refresh it
        if ($null -eq $script:tokenLastRefreshTime -or $script:tokenLastRefreshTime.AddMinutes(55) -lt (Get-Date)) {
            $token.Value = CreateOAUTHToken -TenantID $applicationInfo.TenantID -ClientID $applicationInfo.ClientID -AppSecret $applicationInfo.AppSecret -AzureADEndpoint $AzureADEndpoint -Scope $EWSOnlineScope
            $ewsService.Value = EWSAuth -Environment $Environment -token $token.Value -EWSOnlineURL $EWSOnlineURL
        }
    }

    $mailAddresses = New-Object System.Collections.ArrayList
} process {
    foreach ($address in $UserMailboxes) {
        [void]$mailAddresses.Add($address)
    }
} end {
    Write-Host ("CVE-2023-23397 script version $($BuildVersion)") -ForegroundColor Green

    if ($ScriptUpdateOnly) {
        switch (Test-ScriptVersion -AutoUpdate -VersionsUrl "https://aka.ms/CVE-2023-23397-VersionsUrl" -Confirm:$false) {
            ($true) { Write-Host ("Script was successfully updated") -ForegroundColor Green }
            ($false) { Write-Host ("No update of the script performed") -ForegroundColor Yellow }
            default { Write-Host ("Unable to perform ScriptUpdateOnly operation") -ForegroundColor Red }
        }
        return
    }

    if ((-not($SkipVersionCheck)) -and
        (Test-ScriptVersion -AutoUpdate -Confirm:$false)) {
        Write-Host ("Script was updated. Please rerun the command") -ForegroundColor Yellow
        return
    }

    if ($IgnoreCertificateMismatch) {
        Write-Verbose ("IgnoreCertificateMismatch was used -policy will be set to: TrustAllCertsPolicy")
        Enable-TrustAnyCertificateCallback
    }

    if ($CreateAzureApplication) {
        $null = CreateApplication -AzureEnvironmentName $AzureEnvironmentName -AzureApplicationName $AzureApplicationName
        exit
    }

    if ($DeleteAzureApplication) {
        $null = DeleteApplication -AzureEnvironmentName $AzureEnvironmentName -AzureApplicationName $AzureApplicationName
        exit
    }

    $path = $DLLPath

    if ([System.String]::IsNullOrEmpty($path)) {
        Write-Host "Trying to find Microsoft.Exchange.WebServices.dll in the script folder"
        $path = (Get-ChildItem -LiteralPath "$PSScriptRoot\EWS" -Recurse -Filter "Microsoft.Exchange.WebServices.dll" -ErrorAction SilentlyContinue |
                Select-Object -First 1).FullName

        if ([System.String]::IsNullOrEmpty($path)) {
            Write-Host "Microsoft.Exchange.WebServices.dll wasn't found - attempting to download it from the internet" -ForegroundColor Yellow
            $nuGetPackage = Get-NuGetPackage -PackageId "Microsoft.Exchange.WebServices" -Author "Microsoft"

            if ($nuGetPackage.DownloadSuccessful) {
                $unzipNuGetPackage = Invoke-ExtractArchive -CompressedFilePath $nuGetPackage.NuGetPackageFullPath -TargetFolder "$PSScriptRoot\EWS"

                if ($unzipNuGetPackage.DecompressionSuccessful) {
                    $path = (Get-ChildItem -Path $unzipNuGetPackage.FullPathToDecompressedFiles -Recurse -Filter "Microsoft.Exchange.WebServices.dll" |
                            Select-Object -First 1).FullName
                } else {
                    Write-Host "Failed to unzip Microsoft.Exchange.WebServices.dll. Please unzip the package manually." -ForegroundColor Red
                    exit
                }
            } else {
                Write-Host "Failed to download Microsoft.Exchange.WebServices.dll from the internet. Please download the package manually and extract the dll. Provide the path to dll using DLLPath parameter." -ForegroundColor Red
                exit
            }
        } else {
            Write-Host "Microsoft.Exchange.WebServices.dll was found in the script folder" -ForegroundColor Green
        }
    }

    try {
        Import-Module -Name $path -ErrorAction Stop
    } catch {
        Write-Host "Failed to import Microsoft.Exchange.WebServices.dll Inner Exception`n`n$_" -ForegroundColor Red
        exit
    }

    $failedMailboxes = New-Object 'System.Collections.Generic.List[string]'
    $invalidEntries = New-Object 'System.Collections.Generic.List[string]'
    $removedEntries = New-Object 'System.Collections.Generic.List[string]'

    #MailInfo
    $mailInfo = @{
        "Id"                          = [Microsoft.Exchange.WebServices.Data.ItemSchema]::Id
        "Sender"                      = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::From
        "Recipient"                   = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::ToRecipients
        "Subject"                     = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::Subject
        "DateReceived"                = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::DateTimeReceived
        "PidLidReminderFileParameter" = New-Object Microsoft.Exchange.WebServices.Data.ExtendedPropertyDefinition([Microsoft.Exchange.WebServices.Data.DefaultExtendedPropertySet]::Common, 0x0000851F, [Microsoft.Exchange.WebServices.Data.MapiPropertyType]::String)
        "ItemClass"                   = [Microsoft.Exchange.WebServices.Data.ItemSchema]::ItemClass
    }

    if ($Environment -eq "Online") {
        $application = GetApplicationDetails -AzureApplicationName $AzureApplicationName -AzureEnvironmentName $AzureEnvironmentName

        $applicationInfo = @{
            "TenantID"  = $application.Tenant.Id
            "ClientID"  = $application.ClientID
            "AppSecret" = $application.AppSecret
        }

        #Create OAUTH token
        $EWSToken = CreateOAUTHToken -TenantID $applicationInfo.TenantID -ClientID $applicationInfo.ClientID -AppSecret $applicationInfo.AppSecret -Scope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint

        $ewsService = EWSAuth -Environment $Environment -Token $EWSToken -EWSOnlineURL $EWSOnlineURL
    } else {
        #Server
        $EWSToken = $null
        $ewsService = EWSAuth -Environment $Environment -EWSServerURL $EWSServerURL
    }

    if ($PSCmdlet.ParameterSetName -eq "Audit") {
        if ($null -eq $mailAddresses -or $mailAddresses.Count -eq 0) {
            Write-Host "No mailbox provided" -ForegroundColor Red
            exit
        }

        $csvFileName = ("AuditResults_$(Get-Date -Format "yyyyMMdd_HHmmss").csv")

        $itemView = New-Object Microsoft.Exchange.WebServices.Data.ItemView([int]::MaxValue)

        $searchFilterCollection = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+SearchFilterCollection

        if ($null -ne $StartTimeFilter) {
            $searchFilterStartTime = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+IsGreaterThan([Microsoft.Exchange.WebServices.Data.ItemSchema]::DateTimeCreated, $StartTimeFilter)
            $searchFilterCollection.Add($searchFilterStartTime)
        }

        if ($null -ne $EndTimeFilter) {
            $searchFilterEndTime = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+IsLessThan([Microsoft.Exchange.WebServices.Data.ItemSchema]::DateTimeCreated, $EndTimeFilter)
            $searchFilterCollection.Add($searchFilterEndTime)
        }

        $searchFilterPidLidReminderFileParameterExists = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+Exists($mailInfo["PidLidReminderFileParameter"])
        $searchFilterCollection.Add($searchFilterPidLidReminderFileParameterExists)

        $PropertySet = New-Object Microsoft.Exchange.WebServices.Data.PropertySet
        foreach ($key in $mailInfo.Keys) {
            $PropertySet.Add($mailInfo[$key])
        }

        $mailboxProcessed = 0
        $rowCount = 0

        foreach ($mailAddress in $mailAddresses) {
            $ewsService.HttpHeaders.Clear()
            $ewsService.HttpHeaders.Add("X-AnchorMailbox", $mailAddress)
            Write-Host ("Scanning $($mailboxProcessed + 1) of $($mailAddresses.Count) mailboxes (currently: $mailAddress)")

            $userMailbox = New-Object Microsoft.Exchange.WebServices.Data.Mailbox($mailAddress)

            if ($null -eq $userMailbox) {
                Write-Host ("Unable to get mailbox associated with mail address $mailAddress")
                $failedMailboxes.Add($mailAddress)
                $mailboxProcessed += 1
                continue
            }

            try {
                # Check for token expiry
                CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)

                $rootFolderId = New-Object Microsoft.Exchange.WebServices.Data.FolderId([Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::MsgFolderRoot, $userMailbox)
                $rootFolder = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($ewsService, $rootFolderId)

                # Create a new ArrayList to hold the folder
                $foldersList = New-Object System.Collections.ArrayList

                GetSubFolders -folder $rootFolder -foldersList $foldersList
            } catch [Microsoft.Exchange.WebServices.Data.ServiceResponseException] {
                Write-Host ("Unable to access mailbox: $mailAddress") -ForegroundColor Red
                Write-Host ("Inner Exception: $_") -ForegroundColor Red
                $failedMailboxes.Add($mailAddress)
                $mailboxProcessed += 1
                continue
            } catch {
                Write-Host ("Unable to process mailbox $mailAddress as it seems to be inaccessible. Inner Exception:`n`n$_") -ForegroundColor Red
                $failedMailboxes.Add($mailAddress)
                $mailboxProcessed += 1
                continue
            }

            $IdsProcessed = New-Object 'System.Collections.Generic.HashSet[string]'

            foreach ($folder in $foldersList) {
                try {
                    # Check for token expiry
                    CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                    $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)
                    $results = $ewsService.FindItems($folder.Id, $searchFilterCollection, $itemView)
                    if ($null -ne $results -and $null -ne $results.Items -and $results.Items.Count -gt 0) {
                        $items = $ewsService.LoadPropertiesForItems($results.Items, $PropertySet)
                    } else {
                        continue
                    }

                    foreach ($item in $items) {
                        if (-not $IdsProcessed.Contains($item.Item.Id)) {
                            CreateCustomCSV -mailbox $mailAddress -data $item.Item -CsvPath $csvFileName
                            $rowCount ++
                            if ($rowCount -ge $MaxCSVLength) {
                                Write-Host ("The csv file has reached it's maximum limit of $MaxCSVLength rows... aborting... Please apply appropriate filters to reduce the result size")
                                Write-Host ("Please find the audit results in $csvFileName created in the current folder.")
                                exit
                            }
                            [void]$IdsProcessed.Add($item.Item.Id)
                        }
                    }
                } catch {
                    Write-Host "Error while scanning $($folder.DisplayName) of the mailbox $mailAddress. Inner Exception:`n`n$_" -ForegroundColor Red
                }
            }

            $mailboxProcessed ++;
        }

        if ($rowCount -eq 0) {
            Write-Host "No vulnerable item found" -ForegroundColor Green
        } else {
            Write-Host ("Please find the audit results in $csvFileName created in the current folder.")
        }
    } else {
        $params = @{
            Message   = "Display Warning about Store operation"
            Target    = "The script will perform store operation on mailboxes using EWS"
            Operation = ""
        }

        if ($CleanupAction -eq "ClearProperty") {
            $params.Operation = "Clear the PidLidReminderFileParameter property of mail items"
        }

        if ($CleanupAction -eq "ClearItem") {
            $params.Operation = "Delete items"
        }

        Show-Disclaimer @params

        if (Get-Content -Path $CleanupInfoFilePath -First 1 | Select-String -Pattern '""') {
            Write-Host "Csv file uses double quotation marks and must be normalized"
            $importedCsvData = Import-Csv $CleanupInfoFilePath
            $headerLine = ($importedCsvData[0] | Get-Member | Where-Object {
                    ($_.MemberType -eq "NoteProperty")
                }).Name

            if ($headerLine.Count -eq 1) {
                $cleanupCSV = $importedCsvData | ForEach-Object {
                    ($_.$headerLine)
                } | ConvertFrom-Csv -Header ((($headerLine).Replace('"', "")).Split(","))
            } else {
                Write-Host "Unable to normalize the csv file please reach out to Microsoft support" -ForegroundColor Red
                exit
            }
        } else {
            $cleanupCSV = (Import-Csv $CleanupInfoFilePath -Delimiter ',')
        }

        $entryCount = 0

        foreach ($entry in $cleanupCSV) {
            $entryCount ++
            if ([System.String]::IsNullOrEmpty($entry.Id)) {
                Write-Host ("No Id present for entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                $invalidEntries.Add($entryCount)
                continue
            }

            if ([System.String]::IsNullOrEmpty($entry.Mailbox)) {
                Write-Host ("No Mailbox address present for entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                $invalidEntries.Add($entryCount)
                continue
            }

            if ($null -ne $entry.Cleanup -and $entry.Cleanup.ToLower() -eq "y") {
                # Check for token expiry
                CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $entry.Mailbox)
                $item = FindItem -exchangeService $ewsService -Id $entry.Id
                if ($null -ne $item) {
                    try {
                        if ($CleanupAction -eq "ClearItem") {
                            $item.Delete([Microsoft.Exchange.WebServices.Data.DeleteMode]::HardDelete)
                        } else {
                            if (-not $item.RemoveExtendedProperty($mailInfo["PidLidReminderFileParameter"])) {
                                Write-Host ("Failed to clear property for entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                                $invalidEntries.Add($entryCount)
                                continue
                            }

                            CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint
                            $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $entry.Mailbox)

                            if ($entry.ItemType -eq "Calendar") {
                                $item.Update([Microsoft.Exchange.WebServices.Data.ConflictResolutionMode]::AlwaysOverwrite, [Microsoft.Exchange.WebServices.Data.SendInvitationsOrCancellationsMode]::SendToNone)
                            } else {
                                $item.Update([Microsoft.Exchange.WebServices.Data.ConflictResolutionMode]::AlwaysOverwrite)
                            }
                        }
                        # If we get here, it should be successful.
                        $removedEntries.Add($entryCount)
                    } catch {
                        Write-Host ("Unable to perform cleanup action on entry number: $entryCount, Line number: $($entryCount + 1) Inner Exception`n`n$_") -ForegroundColor Red
                        $invalidEntries.Add($entryCount)
                        continue
                    }
                } else {
                    Write-Host ("Unable to find item associated to entry number: $entryCount, Line number: $($entryCount + 1)") -ForegroundColor Red
                    $invalidEntries.Add($entryCount)
                    continue
                }
            }
        }

        Write-Host "Successfully removed $($removedEntries.Count) of $($cleanupCSV.Count)"

        if ($removedEntries.Count -eq 0) {
            Write-Host "No entries were removed. Please update the Cleanup column for the items you wish to cleanup." -ForegroundColor Yellow
        } else {
            Write-Host "Completed cleanup operation!"
        }
    }

    if ($mode -eq "Audit" -and $null -ne $failedMailboxes -and $failedMailboxes.Count -gt 0) {
        Write-Host ("Couldn't Audit mailboxes: {0}" -f [string]::Join(", ", $failedMailboxes))
    }

    if ($mode -eq "Cleanup" -and $null -ne $invalidEntries -and $invalidEntries.Count -gt 0) {
        Write-Host ("Couldn't Cleanup the entries: {0}" -f [string]::Join(", ", $invalidEntries))
    }

    Write-Host ""
    Write-Host ("Do you have feedback regarding the script? Please email ExToolsFeedback@microsoft.com.") -ForegroundColor Green
    Write-Host ""

    Remove-Module -Name "Microsoft.Exchange.WebServices" -ErrorAction SilentlyContinue
}
